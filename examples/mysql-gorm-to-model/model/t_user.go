package model

import (
	"encoding/json"
	"fmt"
	"github.com/fwhezfwhez/errorx"
	"github.com/garyburd/redigo/redis"
	"github.com/jinzhu/gorm"
	"time"
)

/*
    Code is auto-generated by github.com/fwhezfwhez/model_convert.Package below might be imported:
      - github.com/fwhezfwhez/errorx
      - github.com/garyburd/redigo/redis
      - github.com/jinzhu/gorm
    You can get them by:
      - go get github.com/fwhezfwhez/errorx
      - go get github.com/garyburd/redigo/redis
      - go get github.com/jinzhu/gorm

    To fulfill redis part, don't forget to set TODOs.They are:
      - RedisKey() string
      - RedisSecondDuration() int
*/
type TUser struct {
	Attach    json.RawMessage `gorm:"column:attach;default:" json:"attach" form:"attach"`
	CreatedAt time.Time       `gorm:"column:created_at;default:" json:"created_at" form:"created_at"`
	Id        int             `gorm:"column:id;default:" json:"id" form:"id"`
	Name      string          `gorm:"column:name;default:" json:"name" form:"name"`
}

func (o TUser) TableName() string {
	return "t_user"
}

func (o TUser) RedisKey() string {
	// TODO set its redis key
	return ""
}

func (o TUser) RedisSecondDuration() int {
	// TODO set its redis duration, default 1-7 day,  return -1 means no time limit
	return int(time.Now().Unix()%7+1) * 24 * 60 * 60
}

func (o *TUser) GetFromRedis(conn redis.Conn) error {
	if o.RedisKey() == "" {
		return errorx.NewFromString("object TUser has not set redis key yet")
	}
	buf, e := redis.Bytes(conn.Do("GET", o.RedisKey()))

	if e == nil && string(buf) == "DISABLE" {
		return fmt.Errorf("not found record in db nor redis")
	}

	if e == redis.ErrNil {
		return e
	}

	if e != nil && e != redis.ErrNil {
		return errorx.Wrap(e)
	}

	e = json.Unmarshal(buf, &o)

	if e != nil {
		return errorx.Wrap(e)
	}
	return nil
}

// engine should prepare its condition.
// if record not found,it will return 'var notFound = fmt.Errorf("not found record in db nor redis")'.
// If you want to ignore not found error, do it like:
// if e:= o.MustGet(conn, engine.Model(Model{}).Where("condition =?", arg)).Error;e!=nil {
//     if e.Error() == "not found record in db nor redis"{
//         log.Println(e)
//         return
//     }
// }
func (o *TUser) MustGet(conn redis.Conn, engine *gorm.DB) error {
	e := o.GetFromRedis(conn)
	// When redis key stores its value 'DISABLE', will returns notFoundError and no need to query from db any more
	if e != nil && e.Error() == "not found record in db nor redis" {
		return e
	}

	if e == nil {
		return nil
	}
	if e != nil {
		var count int
		if e2 := engine.Count(&count).Error; e2 != nil {
			return errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e2))
		}
		if count == 0 {
			var notFound = fmt.Errorf("not found record in db nor redis")
			if o.RedisSecondDuration() == -1 {
				conn.Do("SET", o.RedisKey(), "DISABLE", "NX")
			} else {
				conn.Do("SET", o.RedisKey(), "DISABLE", "EX", o.RedisSecondDuration(), "NX")
			}
			return notFound
		}

		if e3 := engine.First(&o).Error; e3 != nil {
			return errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e3))
		}
		if e == redis.ErrNil {
			o.SyncToRedis(conn)
			return nil
		}
		return errorx.Wrap(e)
	}
	return nil
}

func (o TUser) SyncToRedis(conn redis.Conn) error {
	if o.RedisKey() == "" {
		return errorx.NewFromString("object TUser has not set redis key yet")
	}
	buf, e := json.Marshal(o)
	if e != nil {
		return errorx.Wrap(e)
	}
	if o.RedisSecondDuration() == -1 {
		if _, e := conn.Do("SET", o.RedisKey(), buf); e != nil {
			return errorx.Wrap(e)
		}
	} else {
		if _, e := conn.Do("SETEX", o.RedisKey(), o.RedisSecondDuration(), buf); e != nil {
			return errorx.Wrap(e)
		}
	}
	return nil
}

func (o TUser) DeleteFromRedis(conn redis.Conn) error {
	if o.RedisKey() == "" {
		return errorx.NewFromString("object TUser has not set redis key yet")
	}
	if _, e := conn.Do("DEL", o.RedisKey()); e != nil {
		return errorx.Wrap(e)
	}
	return nil
}
